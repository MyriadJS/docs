# :crystal_ball: Scheme
The myriad function is the main function that handles everything. It takes a scheme and a settings object, both of which are optional and whos paramaters all have defaults.

```ts
myriad(scheme, settings)
```
The scheme itself has multiple color parameters which can be though of in terms of groups. Theres the main color parameters background foreground and accents. The additional custom colors. And subscemes. 

```ts 
const scheme = {
  background: '#090233',
  foreground: '#ff5555',
  accents: ['#5200ff'],
  custom: {
    foo: '#00ff00',
    bar: '#ff0000',
  },
  subSchemes: {}
}
```
## :crystal_ball: Schematic Colors
These main colors dictate the entire scheme, and more consisley the main focus should be the foreground and the background. These two colors must have some contrast and the myriad system willl ensure this. They effectgivley dictate the available range of colors to be generated. 

All additional shades get generated as a mix in this range. It is though thinking aboiut colors as background vs foreground that the system manages to understand color readability and context. The accent colors can be though of commonly as brand colors.

```ts 
const scheme = {
  background: '#090233',
  foreground: '#ff5555',
  accents: ['#5200ff'],
}
```

## :crystal_ball: Custom Colors
The custom colors are a way for you to extend the schemantic colors with more spesific named colors. This should be avoided in favor of using schemantic colors as much as possible but are usefull for colors that stand as exeptions to the rest of the theme. Such as success colors, error colors, or link colors. 

By default these colors are handled like accent colors. They are given a contrast color and shades are generated in the same way, and they are adjusted to ensure readability in the same way as accent colors are. 

```ts 
const custom: {
  foo: '#00ff00',
  bar: '#ff0000',
},
```
Heres an example thats a little closer to the practical use case
```ts 
const custom: {
  success: '#00ff00',
  error: '#ff0000',
  link: '#0000ff',
},
```

## :dna: Primitives
Unlike the other colors the custom colors can be assigned with functions. This lets you take control of the system to create your own color logic if you want something else than the standard way that the generator handles accent/custom colors.

In this examplr we are proving a custom color called link with a function that just returns a plain blue color without any adjustement at all. This is likley a bad idea since this color will not be adjusted for readability at all. But its the simplest example of how to use this feature and could be usefull if you for some reason need to guarante no changes to this spesific color and not the entire system.

```ts
myriad({
  foreground: '#ffffff',
  custom: {
    link: () => {
      return '#0000ff'
    }
  }
})
```

Heres a slightly more advanced version where we effectively do the same thing that happens by default, except we are handeling it ourselves by importing the primitives from /core. 

```ts
import { myriad, Myriad, getReadable } from "@myriadjs/core"

function linkColor(generated: Myriad) {
  if(!generated.foreground) return "black"
  return getReadable('#6b6bff', generated, 7)
}

myriad({
  foreground: '#ffffff',
  custom: {
    link: linkColor
  }
})
```

## :crystal_ball: SubSchemes
Here's where the Myriad approach goes from being simple and clean to also being extremely flexible and powerful. The entire system rests on 3 colors - foreground, background, accents. But you might want a more complex theme with more colors. You might have a header that needs a diffirent background color, etc. And although you have multiple accents and you can add custom colors these should be used in limited amounts because they arent meant to control large parts of the theme. 

The obvius option is to run multiple myriad generators with diffirent scemes that attach to diffirent elements. 
```ts
import { myriad } from "@myriadjs/core"

//Theme for the entire site
myriad({
  background: '#0c0915',
  foreground: '#c0aea3',
  accents: ['#c97074'],
}).attach()

//Theme for the header
myriad({
  background: '#c0aea3',
  foreground: '#0c0915',
  accents: ['#c97074'],
}).attach(document.querySelector('.header'))
```
But we can do even better than this, and thats where subSchemes come in. SubSchemes are a way to create a new scheme that inherits from the main scheme. This means that you can create a new scheme that only has to define the colors that are diffirent from the main scheme. It also means that you can describe the entire scheme from a single source, including sub schemes. 

```ts
import { myriad } from "@myriadjs/core"

myriad({
  background: '#0c0915',
  foreground: '#c0aea3',
  accents: ['#c97074'],
  subSchemes: {
    header: {
      background: '#c0aea3',
      foreground: '#0c0915',
    }
  }
})
``` 

Heres a more generic example to hammer home the point that these subSchemes are all arbitrary. 

```ts
myriad({
  background: '#0c0915',
  foreground: '#c0aea3',
  accents: ['#c97074'],
  subSchemes: {
    foo: {
      background: '#c0aea3',
    },
    bar: {
      accents: ['#c0aea3'],
      foreground: '#0c0915',
    },
  }
})
``` 

But this wont work right off the bat. Because how does the system know where to attach the subScheme colors? The inbuilt subScheme handler to the rescue. 

```ts
import { myriad, subScheme } from "@myriadjs/core"

const theme = myriad({
  background: '#0c0915',
  foreground: '#c0aea3',
  accents: ['#c97074'],
  subSchemes: {
    header: {
      accents: ['#c0aea3'],
      foreground: '#0c0915',
    },
  }
}).attach()


subScheme(theme, {
  id: 'header',
  element: document.querySelector('.header') //*note
}).attach()
```

> **Note** 
> This just modifies the default when you call attach. You could ommit this and instead reference the element in the attach call. This same setting also exists on then myriad function itself.

This is just a simple handler that takes a myriad instance and a subScheme object. The subScheme object has an id and an element. The id is the name of the subScheme and the element is the element that the subScheme should be attached to. 

This way you can generate the scheme once, pass the result to whatever page or component you want and then attach the subSchemes to the elements that need them. This lets you describe an infinetly complex theme using the same simple 3 color system. 

More importantly, since its all CSS variables, you can increase then complexity of the theme without increasing the complexity of the code. As long as you keep using the same CSS variables everywhere in your CSS - you can at any point change what those colors mean for the entire site with teh myriad function, or for a specific element with the subScheme function. 

 ::card
 #title
 Infinite scalability without rewriting anything
 #description
 Isn't that neat? The ultimate balance of simplicity and flexibility. It's both scalable and simple. Change your colors at any time without issue. Remove or add entire theme sections at any time without having to rewrite anything
 ::

The subScheme handler is very simple and you could even make it yourself. Heres the entire internals of this function. 

```ts
interface SubSchemeProps {
  id: string
  element: HTMLElement
  settings?: MyriadSettings
}

export const subScheme = (scheme: Myriad, props: SubSchemeProps) => {
  let subSchemes = scheme.subSchemes
  if(subSchemes === undefined) return null
  return myriad(subSchemes[props.id], props)
}
```